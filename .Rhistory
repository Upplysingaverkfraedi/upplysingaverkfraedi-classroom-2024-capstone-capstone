tableOutput("all_teams_average_table")
)
)
)
)
server <- function(input, output, session) {
# Open database connection at the start of the server
con <- dbConnect(RSQLite::SQLite(), "C:/Users/jakob/Documents/GitHub/capstone-thereach/premier_league.db")
# Close the database connection when the app stops
onStop(function() {
if (dbIsValid(con)) {
dbDisconnect(con)
}
})
# Fetch stadium data from the database
stadiums_data <- dbGetQuery(con, "SELECT Team, FDCOUK, City, Stadium, Capacity, Latitude, Longitude, Country FROM Stadiums")
# Define the regex pattern to match only the 20 Premier League teams for the 2019/20 season
teams_pattern <- "\\b(?:Liverpool|Manchester City|Manchester United|Chelsea|Leicester City|Tottenham Hotspur|Wolverhampton Wanderers|Arsenal|Sheffield United|Burnley|Southampton|Everton|Newcastle United|Crystal Palace|Brighton & Hove Albion|West Ham United|Aston Villa|Bournemouth|Watford|Norwich City)\\b"
# Filter stadiums_data to include only the 20 specified teams
Stadiums_data <- stadiums_data %>%
filter(str_detect(Team, teams_pattern))
# Set logo URL for each team in the filtered Stadiums_data
Stadiums_data <- Stadiums_data %>%
mutate(Logo_url = paste0("C:/Users/jakob/Documents/GitHub/capstone-thereach/Logos/", str_replace_all(Team, " ", "_"), ".png"))
# Check if all images exist and issue a warning if not
missing_logos <- Stadiums_data %>% filter(!file.exists(Logo_url))
if (nrow(missing_logos) > 0) {
warning("Missing logo files for teams: ", paste(missing_logos$Team, collapse = ", "))
}
# Convert to sf object for leaflet
Location_data <- st_as_sf(Stadiums_data, coords = c("Longitude", "Latitude"), crs = 4326)
# Create leaflet map with team logos, using only the filtered Stadiums_data
output$stadiums_map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
addMarkers(data = Location_data,
lng = ~st_coordinates(geometry)[, 1],
lat = ~st_coordinates(geometry)[, 2],
icon = ~icons(iconUrl = Logo_url, iconWidth = 30, iconHeight = 30),
popup = ~paste("<b>Team:</b>", Team, "<br><b>Stadium:</b>", Stadium, "<br><b>City:</b>", City, "<br><b>Capacity:</b>", Capacity))
})
# Create a sorted data frame of stadiums for the bar plot
stadiums_sorted <- Stadiums_data %>%
arrange(desc(Capacity))
# Render a ggplot graph with images for stadiums
output$stadium_capacity_plot <- renderPlot({
ggplot(stadiums_sorted, aes(x = reorder(Stadium, Capacity), y = Capacity)) +
geom_image(aes(image = Logo_url), size = 0.05, by = "width") +
coord_flip() +
labs(title = "Stærð valla í Ensku Úrvalsdeildinni (2019/2020 Season)",
x = "Stærð (fjöldi sæta)",
y = "Völlur") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
})
# Populate team selection choices in alphabetical order
observe({
teams <- dbGetQuery(con, "SELECT DISTINCT HomeTeam FROM Games ORDER BY HomeTeam ASC")
updateSelectInput(session, "team_select", choices = teams$HomeTeam)
updateSelectInput(session, "bet_team", choices = teams$HomeTeam)
})
# Calculate league table based on selected game week
league_table_data <- reactive({
query <- paste0("SELECT HomeTeam, AwayTeam, FTHG, FTAG, FTR FROM Games WHERE GW <= ", input$game_week)
weekly_games <- dbGetQuery(con, query)
teams_data <- list()
for (i in 1:nrow(weekly_games)) {
row <- weekly_games[i, ]
home_team <- row$HomeTeam
away_team <- row$AwayTeam
home_goals <- row$FTHG
away_goals <- row$FTAG
result <- row$FTR
if (!(home_team %in% names(teams_data))) {
teams_data[[home_team]] <- list(Played = 0, W = 0, D = 0, L = 0, `+/-` = 0, PTS = 0)
}
if (!(away_team %in% names(teams_data))) {
teams_data[[away_team]] <- list(Played = 0, W = 0, D = 0, L = 0, `+/-` = 0, PTS = 0)
}
teams_data[[home_team]]$Played <- teams_data[[home_team]]$Played + 1
teams_data[[away_team]]$Played <- teams_data[[away_team]]$Played + 1
teams_data[[home_team]]$`+/-` <- teams_data[[home_team]]$`+/-` + (home_goals - away_goals)
teams_data[[away_team]]$`+/-` <- teams_data[[away_team]]$`+/-` + (away_goals - home_goals)
if (result == "H") {
teams_data[[home_team]]$W <- teams_data[[home_team]]$W + 1
teams_data[[home_team]]$PTS <- teams_data[[home_team]]$PTS + 3
teams_data[[away_team]]$L <- teams_data[[away_team]]$L + 1
} else if (result == "A") {
teams_data[[away_team]]$W <- teams_data[[away_team]]$W + 1
teams_data[[away_team]]$PTS <- teams_data[[away_team]]$PTS + 3
teams_data[[home_team]]$L <- teams_data[[home_team]]$L + 1
} else {
teams_data[[home_team]]$D <- teams_data[[home_team]]$D + 1
teams_data[[away_team]]$D <- teams_data[[away_team]]$D + 1
teams_data[[home_team]]$PTS <- teams_data[[home_team]]$PTS + 1
teams_data[[away_team]]$PTS <- teams_data[[away_team]]$PTS + 1
}
}
league_table_df <- do.call(rbind, lapply(names(teams_data), function(team) {
c(Team = team, unlist(teams_data[[team]]))
}))
league_table_df <- as.data.frame(league_table_df, stringsAsFactors = FALSE)
league_table_df[, -1] <- lapply(league_table_df[, -1], as.integer)
league_table_df <- league_table_df[order(-league_table_df$PTS, -league_table_df$`+/-`), ]
league_table_df$POS <- seq_len(nrow(league_table_df))  # Add position
league_table_df
})
output$league_table <- renderTable({
league_data <- league_table_data()
if (is.null(league_data)) {
return(data.frame(Message = "No data available for the selected game week"))
}
league_data[, c("POS", "Team", "Played", "W", "D", "L", "+/-", "PTS")]
}, rownames = FALSE)
# Display the last `n` games for a selected team
output$last_games_table <- renderTable({
team <- input$team_select
num_games <- input$num_games
game_week <- input$game_week  # Use the selected game week as the upper limit
query <- paste0("SELECT GW, HomeTeam, AwayTeam, FTHG, FTAG, FTR FROM Games WHERE (HomeTeam = '", team,
"' OR AwayTeam = '", team, "') AND GW <= ", game_week, " ORDER BY GW DESC LIMIT ", num_games)
last_games <- dbGetQuery(con, query)
last_games <- last_games %>%
mutate(
Opponent = ifelse(HomeTeam == team, AwayTeam, HomeTeam),
Goals = ifelse(HomeTeam == team, paste(FTHG, "-", FTAG), paste(FTAG, "-", FTHG)),
Result = ifelse((HomeTeam == team & FTR == "H") | (AwayTeam == team & FTR == "A"), "W",
ifelse(FTR == "D", "D", "L"))
) %>%
select(GameWeek = GW, Opponent, Goals, Result)
last_games
}, rownames = FALSE)
output$efficiency_plot <- renderPlotly({
fig <- NULL
if (input$plot_choice == "Goals vs. Minutes") {
# Query for Goals vs. Minutes plot
query <- "SELECT PLAYER, MIN, G FROM PlayerStats WHERE MIN > 0 AND G > 0"
plot_data <- dbGetQuery(con, query)
fig <- ggplot(plot_data, aes(x = MIN, y = G, label = PLAYER)) +
geom_point(color = "#1f77b4", size = 3, alpha = 0.7) +  # Blue points with transparency
labs(title = "Goals vs. Minutes Played", x = "Minutes Played", y = "Goals") +
theme_minimal(base_size = 15) +
theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
} else if (input$plot_choice == "Shots on Target vs. Goals") {
# Query for Shots on Target vs. Goals plot
query <- "SELECT PLAYER, SOG, G FROM PlayerStats WHERE SOG > 0"
plot_data <- dbGetQuery(con, query)
fig <- ggplot(plot_data, aes(x = SOG, y = G, label = PLAYER)) +
geom_point(color = "#ff7f0e", size = 3, alpha = 0.7) +  # Orange points with transparency
labs(title = "Shots on Target vs. Goals", x = "Shots on Target", y = "Goals") +
theme_minimal(base_size = 15) +
theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
} else if (input$plot_choice == "Top Goalscorers") {
# Set the number of top scorers
top_n <- input$top_n_scorers
if (input$goal_type == "goals") {
# Query for top goalscorers based on goals only
query <- paste0(
"SELECT PLAYER, G
FROM PlayerStats
WHERE G > 0
ORDER BY G DESC
LIMIT ", top_n
)
plot_data <- dbGetQuery(con, query)
fig <- ggplot(plot_data, aes(x = reorder(PLAYER, -G), y = G, label = PLAYER)) +
geom_bar(stat = "identity", fill = "blue") +
labs(title = paste("Top", top_n, "Goalscorers"), x = "Player", y = "Goals") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
} else {
# Query for top goal contributors based on goals + assists
query <- paste0(
"SELECT PLAYER, (G + ASST) AS Contributions
FROM PlayerStats
WHERE (G + ASST) > 0
ORDER BY Contributions DESC
LIMIT ", top_n
)
plot_data <- dbGetQuery(con, query)
fig <- ggplot(plot_data, aes(x = reorder(PLAYER, -Contributions), y = Contributions, label = PLAYER)) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = paste("Top", top_n, "Goal Contributors (Goals + Assists)"), x = "Player", y = "Goals + Assists") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
}
# Convert ggplot to plotly and add custom layout
ggplotly(fig) %>% layout(
title = list(text = fig$labels$title, x = 0.5, font = list(size = 24, color = "darkblue")),
xaxis = list(title = fig$labels$x, titlefont = list(size = 18)),
yaxis = list(title = fig$labels$y, titlefont = list(size = 18))
)
})
# Populate the dropdown with alphabetically sorted team names
observe({
# Fetch distinct team names from match_status table, sorted alphabetically
teams_query <- "SELECT DISTINCT Name FROM match_status ORDER BY Name ASC"
teams <- dbGetQuery(con, teams_query)$Name
# Update the selectInput with sorted team names
updateSelectInput(session, "selected_teams", choices = teams)
})
output$pointsPlot <- renderPlot({
# Retrieve data from match_status table using SQL and filter based on selected teams
query <- paste0(
"SELECT Name, season, Pts, status_type FROM match_status
WHERE Name IN ('", paste(input$selected_teams, collapse = "', '"), "')
AND season != '2024-2025'"
)
# Run the SQL query to get the plot data
plot_data <- dbGetQuery(con, query)
# Generate the ggplot
ggplot(plot_data, aes(x = season, y = Pts, color = Name, linetype = status_type, group = interaction(Name, status_type))) +
geom_line(linewidth = 1) +
scale_linetype_manual(values = c("All" = "solid", "Home" = "dashed", "Away" = "dotted")) +
labs(x = "Tímabil/Season", y = "Heildarstig", title = "Heildarstig eftir valin lið") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
# Debugging step: Print database connection and query
observe({
print("Database connection status:")
print(dbIsValid(con))
})
output$betting_progress <- renderPlotly({
team <- input$bet_team
team_games_query <- paste0(
"SELECT
ROW_NUMBER() OVER (ORDER BY Date) AS Week,  -- Use row numbering instead of GameWeek if Date exists
CASE
WHEN HomeTeam = '", team, "' AND FTR = 'H' THEN (B365H * 10) - 10
WHEN AwayTeam = '", team, "' AND FTR = 'A' THEN (B365A * 10) - 10
ELSE -10
END AS Profit
FROM Games
WHERE HomeTeam = '", team, "' OR AwayTeam = '", team, "'"
)
team_games <- dbGetQuery(con, team_games_query)
# Calculate cumulative profit
team_games$Cumulative_Profit <- cumsum(team_games$Profit)
# Plot using plotly
fig <- plot_ly()
for (i in 2:nrow(team_games)) {
segment_color <- ifelse(team_games$Cumulative_Profit[i-1] >= 0, "green", "red")
fig <- fig %>%
add_trace(
x = team_games$Week[(i-1):i],
y = team_games$Cumulative_Profit[(i-1):i],
type = 'scatter',
mode = 'lines+markers',
line = list(color = segment_color, width = 2),
marker = list(color = segment_color, size = 8),
hoverinfo = "text",
text = paste("Week:", team_games$Week[(i-1):i], "<br>Profit:", round(team_games$Cumulative_Profit[(i-1):i], 2)),
showlegend = FALSE
)
}
fig <- fig %>%
layout(
title = paste("Uppsafnaður hagnaður/tap fyrir ", team),
xaxis = list(title = "Leikvika"),
yaxis = list(title = "Uppsafnaður hagnaður/tap ($)")
)
fig
})
output$end_season_profit_loss <- renderUI({
req(input$bet_team)
team <- input$bet_team
season_profit_query <- paste0(
"SELECT
SUM(CASE
WHEN HomeTeam = '", team, "' AND FTR = 'H' THEN (B365H * 10) - 10
WHEN AwayTeam = '", team, "' AND FTR = 'A' THEN (B365A * 10) - 10
ELSE -10
END) AS Cumulative_Profit
FROM Games
WHERE HomeTeam = '", team, "' OR AwayTeam = '", team, "'"
)
season_profit <- dbGetQuery(con, season_profit_query)$Cumulative_Profit
color <- ifelse(season_profit >= 0, "green", "red")
HTML(paste0(
'<div style="border: 2px solid ', color, '; padding: 15px; margin: 15px 0; border-radius: 8px; background-color: ', color, '10;">',
'<h4 style="color: ', color, ';"><i class="fa fa-dollar-sign"></i> Lok tímabils hagnaður/tap</h4>',
'<p style="font-size: 1.2em; color: ', color, ';">$', round(season_profit, 2), '</p>',
'</div>'
))
})
# Query 1: Calculate fouls per card for each referee
output$fouls_per_card_plot <- renderPlotly({
query <- "
SELECT
Referee,
SUM(HF + AF) AS Total_Fouls,
SUM(HY + AY) AS Total_Yellow_Cards,
SUM(HR + AR) AS Total_Red_Cards
FROM
games
GROUP BY
Referee;
"
referee_data <- dbGetQuery(con, query)
referee_data$Total_Cards <- referee_data$Total_Yellow_Cards + referee_data$Total_Red_Cards
referee_data$Fouls_Per_Card <- referee_data$Total_Fouls / referee_data$Total_Cards
fig <- ggplot(referee_data, aes(x = reorder(Referee, -Fouls_Per_Card), y = Fouls_Per_Card)) +
geom_bar(stat = "identity") +
labs(title = "Brot á hvert spjald að meðaltali fyrir hvern og einn dómara",
x = "Dómari",
y = "Brot á hvert spjald") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplotly(fig)
})
# Query 2: Distribution of home wins, draws, and away wins
output$win_distribution_pie <- renderPlotly({
query <- "
SELECT
SUM(CASE WHEN FTR = 'H' THEN 1 ELSE 0 END) AS Total_Home_Team_Wins,
SUM(CASE WHEN FTR = 'D' THEN 1 ELSE 0 END) AS Total_Draws,
SUM(CASE WHEN FTR = 'A' THEN 1 ELSE 0 END) AS Total_Away_Team_Wins
FROM
games;
"
win_data <- dbGetQuery(con, query)
plot_ly(
labels = c("Heima sigrar", "Jafntefli", "Úti sigrar"),
values = c(win_data$Total_Home_Team_Wins, win_data$Total_Draws, win_data$Total_Away_Team_Wins),
type = "pie",
textinfo = "label+percent",
insidetextorientation = "radial"
) %>% layout(title = "Dreifing á sigrum")
})
# Query 3: Number of wins by the team each referee officiated for the most
output$referee_most_wins_bar <- renderPlotly({
query <- "
SELECT Referee, WinningTeam, MAX(Wins) AS Wins FROM (
SELECT Referee,
CASE WHEN FTR = 'H' THEN HomeTeam ELSE AwayTeam END AS WinningTeam,
COUNT(*) AS Wins
FROM Games
WHERE FTR IN ('H', 'A')
GROUP BY Referee, WinningTeam
)
GROUP BY Referee
ORDER BY Wins DESC;
"
referee_most_wins <- dbGetQuery(con, query)
fig <- ggplot(referee_most_wins, aes(x = Referee, y = Wins, fill = WinningTeam)) +
geom_bar(stat = "identity") +
labs(title = "Sigursælasta lið hvers dómara",
x = "Dómari", y = "Fjöldi sigra") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplotly(fig)
})
# Populate team choices for comparison
observe({
teams <- dbGetQuery(con, "SELECT DISTINCT HomeTeam FROM Games ORDER BY HomeTeam ASC")
# Populate "Veldu lið 1" in alphabetical order
updateSelectInput(session, "team1", choices = teams$HomeTeam)
# Populate "Veldu lið 2" in reverse alphabetical order
updateSelectInput(session, "team2", choices = rev(teams$HomeTeam))
})
# Helper function to calculate weekly goals scored and conceded
# Combine data for both teams in a single function
# Function to get combined metrics for both teams
# Function to calculate weekly metrics for both teams
get_combined_weekly_metric <- function(team1, team2, metric) {
query <- paste0("SELECT GW, HomeTeam, AwayTeam, FTHG, FTAG, HC, AC, \"HS\", \"AS\", HST, AST, HF, AF, HY, AY, HR, AR
FROM Games WHERE (HomeTeam = '", team1, "' OR AwayTeam = '", team1, "' OR
HomeTeam = '", team2, "' OR AwayTeam = '", team2, "') ORDER BY GW")
team_games <- dbGetQuery(con, query)
# Calculate the metric for both teams
team1_metric <- team_games %>%
filter(HomeTeam == team1 | AwayTeam == team1) %>%
mutate(Metric_Value = switch(metric,
"goals_scored" = ifelse(HomeTeam == team1, FTHG, FTAG),
"goals_conceded" = ifelse(HomeTeam == team1, FTAG, FTHG),
"corners_won" = ifelse(HomeTeam == team1, HC, AC),
"corners_conceded" = ifelse(HomeTeam == team1, AC, HC),
"shots" = ifelse(HomeTeam == team1, `HS`, `AS`),
"shots_on_target" = ifelse(HomeTeam == team1, HST, AST),
"fouls" = ifelse(HomeTeam == team1, HF, AF),
"yellow_cards" = ifelse(HomeTeam == team1, HY, AY),
"red_cards" = ifelse(HomeTeam == team1, HR, AR))) %>%
group_by(GW) %>%
summarize(Total_Metric_Value = sum(Metric_Value, na.rm = TRUE)) %>%
mutate(Team = team1)
team2_metric <- team_games %>%
filter(HomeTeam == team2 | AwayTeam == team2) %>%
mutate(Metric_Value = switch(metric,
"goals_scored" = ifelse(HomeTeam == team2, FTHG, FTAG),
"goals_conceded" = ifelse(HomeTeam == team2, FTAG, FTHG),
"corners_won" = ifelse(HomeTeam == team2, HC, AC),
"corners_conceded" = ifelse(HomeTeam == team2, AC, HC),
"shots" = ifelse(HomeTeam == team2, `HS`, `AS`),
"shots_on_target" = ifelse(HomeTeam == team2, HST, AST),
"fouls" = ifelse(HomeTeam == team2, HF, AF),
"yellow_cards" = ifelse(HomeTeam == team2, HY, AY),
"red_cards" = ifelse(HomeTeam == team2, HR, AR))) %>%
group_by(GW) %>%
summarize(Total_Metric_Value = sum(Metric_Value, na.rm = TRUE)) %>%
mutate(Team = team2)
combined_metric <- bind_rows(team1_metric, team2_metric)
combined_metric
}
# Reactive value to track the view mode
view_mode <- reactiveVal("graph")
# Update view mode when buttons are clicked
observeEvent(input$show_graph, {
view_mode("graph")
})
observeEvent(input$show_table, {
view_mode("table")
})
# Define the get_team_average_metric function for a single team and metric
get_team_average_metric <- function(team_name, metric) {
query <- paste0("SELECT HomeTeam, AwayTeam, FTHG, FTAG, HC, AC, \"HS\", \"AS\", HST, AST, HF, AF, HY, AY, HR, AR
FROM Games WHERE HomeTeam = '", team_name, "' OR AwayTeam = '", team_name, "'")
team_games <- dbGetQuery(con, query)
avg_metric <- team_games %>%
mutate(Metric_Value = switch(metric,
"goals_scored" = ifelse(HomeTeam == team_name, FTHG, FTAG),
"goals_conceded" = ifelse(HomeTeam == team_name, FTAG, FTHG),
"corners_won" = ifelse(HomeTeam == team_name, HC, AC),
"corners_conceded" = ifelse(HomeTeam == team_name, AC, HC),
"shots" = ifelse(HomeTeam == team_name, `HS`, `AS`),
"shots_on_target" = ifelse(HomeTeam == team_name, HST, AST),
"fouls" = ifelse(HomeTeam == team_name, HF, AF),
"yellow_cards" = ifelse(HomeTeam == team_name, HY, AY),
"red_cards" = ifelse(HomeTeam == team_name, HR, AR))) %>%
summarize(Average_Metric_Value = mean(Metric_Value, na.rm = TRUE)) %>%
mutate(Team = team_name)
avg_metric
}
# Function to calculate season averages for all teams across all metrics
get_all_teams_average <- function() {
teams <- dbGetQuery(con, "SELECT DISTINCT HomeTeam FROM Games ORDER BY HomeTeam ASC")$HomeTeam
# Initialize a data frame to store all metrics for all teams
all_teams_average <- data.frame(
Team = character(),
`Goals Scored` = numeric(),
`Goals Conceded` = numeric(),
`Corners Won` = numeric(),
`Corners Conceded` = numeric(),
`Shots` = numeric(),
`Shots on Target` = numeric(),
`Fouls` = numeric(),
`Yellow Cards` = numeric(),
`Red Cards` = numeric(),
stringsAsFactors = FALSE
)
# Loop through each team and calculate averages for each metric
for (team in teams) {
avg_goals_scored <- get_team_average_metric(team, "goals_scored")$Average_Metric_Value
avg_goals_conceded <- get_team_average_metric(team, "goals_conceded")$Average_Metric_Value
avg_corners_won <- get_team_average_metric(team, "corners_won")$Average_Metric_Value
avg_corners_conceded <- get_team_average_metric(team, "corners_conceded")$Average_Metric_Value
avg_shots <- get_team_average_metric(team, "shots")$Average_Metric_Value
avg_shots_on_target <- get_team_average_metric(team, "shots_on_target")$Average_Metric_Value
avg_fouls <- get_team_average_metric(team, "fouls")$Average_Metric_Value
avg_yellow_cards <- get_team_average_metric(team, "yellow_cards")$Average_Metric_Value
avg_red_cards <- get_team_average_metric(team, "red_cards")$Average_Metric_Value
# Add the team's averages to the data frame
all_teams_average <- rbind(all_teams_average, data.frame(
Team = team,
`Goals Scored` = avg_goals_scored,
`Goals Conceded` = avg_goals_conceded,
`Corners Won` = avg_corners_won,
`Corners Conceded` = avg_corners_conceded,
`Shots` = avg_shots,
`Shots on Target` = avg_shots_on_target,
`Fouls` = avg_fouls,
`Yellow Cards` = avg_yellow_cards,
`Red Cards` = avg_red_cards,
stringsAsFactors = FALSE
))
}
all_teams_average
}
# Render the view_mode reactive value as output for conditionalPanel
output$view_mode <- reactive(view_mode())
# Render combined plot for team comparison
output$team_metric_plot <- renderPlotly({
req(input$team1, input$team2, input$comparison_metric, view_mode() == "graph")
combined_metric <- get_combined_weekly_metric(input$team1, input$team2, input$comparison_metric)
fig <- plot_ly(combined_metric, x = ~GW, y = ~Total_Metric_Value, color = ~Team, type = 'scatter', mode = 'lines+markers') %>%
layout(
title = paste("Comparison of", input$comparison_metric, "between", input$team1, "and", input$team2),
xaxis = list(title = "Game Week"),
yaxis = list(title = "Metric Value"),
legend = list(title = list(text = "Teams"))
)
fig
})
# Render table showing average metric for each team
output$average_metric_table <- renderTable({
req(input$team1, input$team2, input$comparison_metric, view_mode() == "graph")
team1_avg <- get_team_average_metric(input$team1, input$comparison_metric)
team2_avg <- get_team_average_metric(input$team2, input$comparison_metric)
average_table <- bind_rows(team1_avg, team2_avg)
average_table <- average_table %>%
select(Team, Average_Metric_Value) %>%
rename("Team" = Team, "Average" = Average_Metric_Value)
average_table
})
# Render table showing averages for all teams and all metrics
output$all_teams_average_table <- renderTable({
req(view_mode() == "table")
all_teams_average <- get_all_teams_average()
all_teams_average
})
# Set output options for conditional panels
outputOptions(output, "view_mode", suspendWhenHidden = FALSE)
}
shinyApp(ui, server)
